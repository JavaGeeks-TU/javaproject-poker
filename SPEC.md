### **[Masterpiece] AI vs Player 1:1 텍사스 홀덤 기능 명세서**

#### **1. 프로젝트 개요**

*   **게임 이름:** Console Hold'em
*   **플랫폼:** Java Console
*   **게임 방식:** 플레이어(Human)와 AI(Computer)가 1대 1로 텍사스 홀덤을 플레이한다. 한쪽의 칩이 모두 소진되면 게임이 종료된다.
*   **핵심 목표:** 텍사스 홀덤의 기본 규칙을 정확히 구현하고, AI가 기본적인 전략에 따라 행동하게 만든다.

#### **2. 핵심 데이터 구조 (클래스 설계의 기반)**

*   **Card:** 카드의 무늬(Suit)와 랭크(Rank)를 가짐 (e.g., 하트 A)
*   **Deck:** 52장의 `Card` 객체를 가지며, 셔플(Shuffle) 및 카드 드로우(Draw) 기능을 제공.
*   **Player:** 이름(Name), 보유 칩(Chips), 현재 핸드(2장의 카드) 등 플레이어의 상태를 관리. (Human과 AI는 이 `Player`를 상속 또는 구현하여 사용)
*   **GameState:** 현재 팟(Pot) 크기, 커뮤니티 카드, 현재 턴, 딜러(버튼) 위치 등 게임의 전반적인 상태를 관리.

---

#### **3. 상세 기능 명세 (Feature Specification)**

**F-01: 게임 시작 및 설정 (Game Setup)**

*   [ ] `[필수]` 게임 시작 시, 플레이어의 이름을 입력받는다. AI의 이름은 'Computer'로 고정한다.
*   [ ] `[필수]` 플레이어와 AI에게 동일한 시작 칩을 지급한다. (예: 1,000)
*   [ ] `[필수]` 첫 핸드의 딜러(버튼)를 랜덤하게 결정한다. (이후 매 핸드마다 역할 교대)
*   [ ] `[필수]` 스몰 블라인드(SB)와 빅 블라인드(BB) 금액을 설정한다. (예: SB 5, BB 10)

**F-02: 핸드(Hand) 진행 사이클**

*   [ ] `[필수]` **[준비 단계]** 새로운 `Deck`을 생성하고 셔플한다.
*   [ ] `[필수]` **[블라인드 베팅]** 딜러가 아닌 플레이어는 SB, 딜러는 BB를 자동으로 베팅하여 팟(Pot)에 추가한다.
*   [ ] `[필수]` **[카드 분배]** 각 플레이어(Human, AI)에게 2장의 카드를 비공개로 나눠준다.
*   [ ] `[필수]` **[Pre-flop 베팅]** SB 플레이어부터 첫 번째 베팅 라운드를 시작한다.
*   [ ] `[필수]` **[Flop]** 베팅 종료 후, 커뮤니티 카드 3장을 공개한다.
    *   _예외 처리: 한쪽이 폴드했다면 즉시 핸드를 종료하고 F-05로 넘어간다._
*   [ ] `[필수]` **[Flop 베팅]** SB 플레이어부터 두 번째 베팅 라운드를 시작한다.
*   [ ] `[필수]` **[Turn]** 베팅 종료 후, 커뮤니티 카드 1장을 추가로 공개한다.
*   [ ] `[필수]` **[Turn 베팅]** SB 플레이어부터 세 번째 베팅 라운드를 시작한다.
*   [ ] `[필수]` **[River]** 베팅 종료 후, 마지막 커뮤니티 카드 1장을 공개한다.
*   [ ] `[필수]` **[River 베팅]** SB 플레이어부터 마지막 베팅 라운드를 시작한다.

**F-03: 플레이어 및 AI 액션 (Player & AI Actions)**

*   [ ] `[필수]` 자신의 턴이 되면, 현재 가능한 액션 목록을 콘솔에 출력해야 한다.
*   [ ] `[필수]` **Check:** 베팅 없이 턴을 넘긴다. (앞서 베팅이 없었을 경우에만 가능)
*   [ ] `[필수]` **Call:** 상대방이 베팅한 금액만큼 동일하게 베팅한다.
*   [ ] `[필수]` **Bet:** 아무도 베팅하지 않았을 때, 새로운 금액을 베팅한다.
*   [ ] `[필수]` **Raise:** 상대방의 베팅보다 더 많은 금액으로 베팅한다.
*   [ ] `[필수]` **Fold:** 핸드를 포기한다. 즉시 해당 핸드는 상대방의 승리로 끝난다.
*   [ ] `[필수]` **All-in:** 자신의 모든 칩을 베팅한다.

**F-04: AI 로직 (초급 버전)**

*   [ ] `[핵심]` **[Pre-flop]** 자신의 카드 2장을 기준으로 플레이 여부를 결정한다.
    *   (예시) 포켓 페어(A-A, K-K...), 높은 숫자 카드(A-K, A-Q...), 수딧 커넥터(8-9 suited) 등 미리 정해진 좋은 핸드일 경우에만 `Call` 또는 `Raise`.
    *   (예시) 좋지 않은 핸드(2-7 offsuit 등)일 경우 `Fold` 또는 상대방의 `Raise`가 없을 때만 `Call`.
*   [ ] `[핵심]` **[Post-flop 이후]** 자신의 핸드와 커뮤니티 카드를 조합하여 족보를 확인한다.
    *   (예시) `One Pair` 이상이 맞춰졌을 경우: `Check` 또는 `Bet`. 상대가 `Bet`하면 `Call`.
    *   (예시) 아무것도 맞추지 못했을 경우(High Card): `Check`. 상대가 `Bet`하면 `Fold`.
    *   (예시) `Two Pair` 이상 강력한 족보가 맞춰졌을 경우: `Bet` 또는 `Raise`.

**F-05: 쇼다운 및 결과 처리 (Showdown & Result)**

*   [ ] `[필수]` 마지막 베팅 라운드 후 두 플레이어가 모두 폴드하지 않았을 경우, 쇼다운을 진행한다.
*   [ ] `[필수]` **[족보 판정 로직]** 각 플레이어의 카드 2장과 커뮤니티 카드 5장을 조합하여 만들 수 있는 가장 높은 족보를 판정한다.
    *   (로얄 플러시 > 스트레이트 플러시 > 포카드 > 풀하우스 > 플러시 > 스트레이트 > 트리플 > 투 페어 > 원 페어 > 하이 카드)
*   [ ] `[필수]` **[승자 판정]** 더 높은 족보를 가진 플레이어가 승리한다.
*   [ ] `[필수]` **[무승부 처리]** 족보가 같을 경우, 팟을 두 플레이어에게 똑같이 분배한다. (Kicker 규칙은 초기 버전에서는 제외 가능)
*   [ ] `[필수]` 팟에 쌓인 모든 칩을 승자에게 전달하고, 결과를 콘솔에 출력한다. (예: "플레이어, Royal Flush로 승리!")

**F-06: 게임 종료 및 재시작 (Game Over & Replay)**

*   [ ] `[필수]` 한 핸드가 끝날 때마다 각 플레이어의 남은 칩을 표시한다.
*   [ ] `[필수]` 한 플레이어의 칩이 0이 되면 게임이 종료되고, 최종 승자를 선언한다.
*   [ ] `[선택]` 게임 종료 후, 재시작 여부를 묻는 옵션을 제공한다.

**F-07: 콘솔 UI/UX (Console Display)**

*   [ ] `[필수]` 매 턴마다 현재 팟(Pot) 크기, 커뮤니티 카드, 각 플레이어의 칩 정보를 명확하게 보여준다.
*   [ ] `[필수]` 플레이어의 핸드 카드는 항상 보여주고, AI의 카드는 쇼다운 시에만 공개한다.
*   [ ] `[필수]` AI의 액션(Check, Bet 등)과 베팅 금액을 텍스트로 명확히 출력한다. (예: "Computer가 50을 Bet 했습니다.")
*   [ ] `[권장]` `Thread.sleep()` 등을 활용해 AI가 생각하는 듯한 딜레이(1~2초)를 주어 게임 경험을 향상시킨다.

---

**개발 진행 가이드:**

1.  **1단계 (구조 잡기):** `Card`, `Deck`, `Player` 등 **F-02**의 데이터 구조 클래스부터 만드세요. 카드 셔플, 분배 기능만 먼저 구현합니다.
2.  **2단계 (흐름 만들기):** **F-02**의 핸드 진행 사이클(블라인드 베팅 ~ 리버)의 기본 흐름을 코드로 구현합니다. 아직 실제 베팅 로직은 비워둬도 좋습니다.
3.  **3단계 (핵심 로직 구현):** **F-03**의 플레이어 액션과 **F-05**의 족보 판정 로직을 구현합니다. 이 부분이 가장 복잡하고 중요합니다.
4.  **4단계 (AI 탑재):** **F-04**의 간단한 AI 로직을 구현하여 플레이어 대신 결정을 내리게 합니다.
5.  **5단계 (완성 및 다듬기):** **F-01, F-06, F-07** 등 게임의 시작/종료 처리 및 UI를 다듬어 완성도를 높입니다.

이 명세서를 **Notion, GitHub Wiki** 등에 올려두고, 개발이 완료된 항목을 하나씩 체크해 나가면서 진행하면 두 분이 항상 같은 목표를 향해 나아갈 수 있을 겁니다.